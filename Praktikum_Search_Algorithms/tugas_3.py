# -*- coding: utf-8 -*-
"""Tugas 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Lm8ZLxBCOpeJamoi5NcoP1LYVM3311Zy
"""

import heapq

class Graph:
    def __init__(self):
        self.edges = {}
        self.heuristic = {}

    def add_edge(self, node1, node2, cost):
        if node1 not in self.edges:
            self.edges[node1] = []
        if node2 not in self.edges:
            self.edges[node2] = []

        self.edges[node1].append((node2, cost))
        self.edges[node2].append((node1, cost))  # Jika graf tidak berarah

    def set_heuristic(self, heuristics):
        self.heuristic = heuristics

    def greedy_best_first_search(self, start, goal):
        open_list = []
        heapq.heappush(open_list, (self.heuristic[start], start))
        came_from = {start: None}

        while open_list:
            _, current = heapq.heappop(open_list)

            if current == goal:
                return self.reconstruct_path(came_from, goal)

            for neighbor, _ in self.edges.get(current, []):
                if neighbor not in came_from:
                    came_from[neighbor] = current
                    heapq.heappush(open_list, (self.heuristic[neighbor], neighbor))

        return None  # Jika tidak ditemukan

    def a_star_search(self, start, goal):
        open_list = []
        heapq.heappush(open_list, (self.heuristic[start], 0, start))
        g_score = {start: 0}
        came_from = {start: None}

        while open_list:
            _, cost, current = heapq.heappop(open_list)

            if current == goal:
                return self.reconstruct_path(came_from, goal)

            for neighbor, move_cost in self.edges.get(current, []):
                temp_g_score = g_score[current] + move_cost
                if neighbor not in g_score or temp_g_score < g_score[neighbor]:
                    g_score[neighbor] = temp_g_score
                    f_score = temp_g_score + self.heuristic[neighbor]
                    heapq.heappush(open_list, (f_score, temp_g_score, neighbor))
                    came_from[neighbor] = current

        return None

    def reconstruct_path(self, came_from, current):
        path = []
        while current is not None:
            path.append(current)
            current = came_from[current]
        path.reverse()
        return path

# Membuat graf sesuai dengan gambar
graph = Graph()
graph.add_edge('S', 'A', 2)
graph.add_edge('S', 'B', 3)
graph.add_edge('A', 'D', 4)
graph.add_edge('A', 'B', 1)
graph.add_edge('B', 'C', 3)
graph.add_edge('D', 'G', 1)
graph.add_edge('C', 'G', 4)

graph.set_heuristic({'S': 6, 'A': 4, 'B': 3, 'C': 2, 'D': 1, 'G': 0})

# Jalankan algoritma
start, goal = 'S', 'G'
print("Greedy Best-First Search Path:", graph.greedy_best_first_search(start, goal))
print("A* Search Path:", graph.a_star_search(start, goal))